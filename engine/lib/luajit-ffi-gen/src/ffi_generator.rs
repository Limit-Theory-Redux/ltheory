use std::env::VarError;
use std::fmt::Write as FmtWrite;
use std::fs::File;
use std::io::Write as IoWrite;
use std::path::PathBuf;

use serde::{Deserialize, Serialize};

use crate::IDENT;

const LUAJIT_FFI_GEN_DIR_ENV: &str = "LUAJIT_FFI_GEN_DIR";
const LUAJIT_FFI_GEN_DIR: &str = "../phx/script/ffi_gen";
const LUAJIT_FFI_META_DIR_ENV: &str = "LUAJIT_FFI_GEN_DIR";
const LUAJIT_FFI_META_DIR: &str = "../phx/script/meta";

/// FFI type declaration type.
#[derive(Debug, Default, Serialize, Deserialize)]
pub enum TypeDecl {
    /// Simple type. Used for manual type aliases declared in libphx.lua.
    #[default]
    NoDecl,
    /// Opaque type declaration. Used for complex Rust types sent by reference.
    Opaque,
    /// Autogenerated transparent type aliases. Parameter contains aliased type name.
    Struct(String),
}

impl TypeDecl {
    /// Type declaration identifier used in the generated `Loader.defineType()` Lua functions.
    fn id(&self) -> u8 {
        match self {
            TypeDecl::NoDecl => 0,
            TypeDecl::Opaque => 1,
            TypeDecl::Struct(_) => 2,
        }
    }
}

/// Lua FFI module generator. Used also to transfer information between `enum`` (and potentially `struct``) and `impl` attribute usages.
#[derive(Debug, Serialize, Deserialize)]
pub struct FfiGenerator {
    module_name: String,
    type_decl: TypeDecl,
    class_definitions: Vec<String>,
    c_definitions: Vec<String>,
    global_symbol_table: Vec<String>,
    is_mt_clone: bool,
    to_string_method: Option<String>,
    metatype: Vec<String>,
}

/// Initialization
impl FfiGenerator {
    /// Create generator for module.
    pub fn new(module_name: &str) -> Self {
        Self {
            module_name: module_name.into(),
            type_decl: Default::default(),
            class_definitions: Default::default(),
            c_definitions: Default::default(),
            global_symbol_table: Default::default(),
            is_mt_clone: Default::default(),
            to_string_method: Default::default(),
            metatype: Default::default(),
        }
    }

    pub fn set_type_decl_opaque(&mut self) {
        self.type_decl = TypeDecl::Opaque;
    }

    pub fn set_type_decl_struct(&mut self, ty: impl Into<String>) {
        self.type_decl = TypeDecl::Struct(ty.into());
    }

    pub fn has_type_decl(&self) -> bool {
        !matches!(self.type_decl, TypeDecl::NoDecl)
    }

    pub fn add_class_definition(&mut self, value: impl Into<String>) {
        self.class_definitions.push(value.into());
    }

    pub fn has_class_definitions(&self) -> bool {
        !self.class_definitions.is_empty()
    }

    pub fn add_c_definition(&mut self, value: impl Into<String>) {
        self.c_definitions.push(value.into());
    }

    pub fn has_c_definitions(&self) -> bool {
        !self.c_definitions.is_empty()
    }

    pub fn add_global_symbol(&mut self, value: impl Into<String>) {
        self.global_symbol_table.push(value.into());
    }

    pub fn has_global_symbols(&self) -> bool {
        !self.global_symbol_table.is_empty()
    }

    pub fn set_mt_clone(&mut self) {
        self.is_mt_clone = true;
    }

    pub fn set_to_string_method(&mut self, method: &str) {
        self.to_string_method = Some(method.into());
    }

    pub fn add_metatype(&mut self, value: impl Into<String>) {
        self.metatype.push(value.into());
    }
}

/// Serialization and deserialization
impl FfiGenerator {
    /// Deserialize generator from the `json` file in the `target/ffi` folder
    /// or create default one if file doesn't exist.
    pub fn load(module_name: &str) -> Self {
        let target_ffi_file = Self::ffi_file(module_name);

        if !target_ffi_file.exists() {
            return Self::new(module_name);
        }

        let data = std::fs::read_to_string(&target_ffi_file)
            .expect(&format!("Cannot load {target_ffi_file:?} FFI data file"));

        let res: Self = serde_json::from_str(&data)
            .expect(&format!("Cannot parse {target_ffi_file:?} FFI data file"));

        std::fs::remove_file(&target_ffi_file)
            .expect(&format!("Cannot remove {target_ffi_file:?} FFI data file"));

        assert_eq!(res.module_name, module_name);

        res
    }

    /// Serialize generator into the `json` file in the `target/ffi` folder.
    pub fn save(&self) {
        let data = serde_json::to_string(self)
            .expect(&format!("Cannot serialize {} data", self.module_name));

        let target_ffi_dir = Self::ffi_dir();

        std::fs::create_dir_all(&target_ffi_dir)
            .expect(&format!("Cannot create {target_ffi_dir:?} folder"));

        let target_ffi_file = Self::ffi_file(&self.module_name);

        std::fs::write(&target_ffi_file, data)
            .expect(&format!("Cannot save {target_ffi_file:?} FFI data file"));
    }

    fn ffi_dir() -> PathBuf {
        // TODO: env!("OUT_DIR") doesn't work
        PathBuf::from("target").join("ffi")
    }

    fn ffi_file(module_name: &str) -> PathBuf {
        Self::ffi_dir().join(format!("{module_name}.json"))
    }
}

/// Generation
impl FfiGenerator {
    /// Generates Lua FFI file.
    /// It contains the Loader object with 2 functions: `declareType()` and `defineType()`.
    /// Former registers type C declaration, either opaque or transparent, and returns type's id (0 - manual type, 1 - opaque, 2 -transparent)
    /// and type name.
    /// Latter does overall type registration: c function declarations, symbol table registration, etc.
    pub fn generate(&self) {
        let ffi_gen_dir = from_env_or_default(LUAJIT_FFI_GEN_DIR_ENV, LUAJIT_FFI_GEN_DIR);

        let cargo_manifest_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));

        let ffi_gen_dir_path = cargo_manifest_dir.join(&ffi_gen_dir);
        assert!(
            ffi_gen_dir_path.exists(),
            "FFI directory '{}' doesn't exist",
            ffi_gen_dir_path.display()
        );

        let ffi_module_path = ffi_gen_dir_path.join(format!("{}.lua", self.module_name));
        let mut module_file = File::create(&ffi_module_path).expect(&format!(
            "Cannot create file: {ffi_module_path:?}\nCurrent folder: {:?}",
            std::env::current_dir()
        ));

        let mut module = String::new();

        // Header
        writeln!(
            &mut module,
            "-- {} {:-<2$}",
            self.module_name,
            "-",
            80 - 4 - self.module_name.len()
        )
        .unwrap();

        writeln!(&mut module, "local Loader = {{}}\n").unwrap();

        // Type declaration
        writeln!(&mut module, "function Loader.declareType()").unwrap();

        match &self.type_decl {
            TypeDecl::NoDecl => {}
            TypeDecl::Opaque => {
                writeln!(&mut module, "{IDENT}ffi.cdef [[").unwrap();
                writeln!(
                    &mut module,
                    "{IDENT}{IDENT}typedef struct {0} {{}} {0};",
                    self.module_name
                )
                .unwrap();
                writeln!(&mut module, "{IDENT}]]\n").unwrap();
            }
            TypeDecl::Struct(ty) => {
                writeln!(&mut module, "{IDENT}ffi.cdef [[").unwrap();
                writeln!(
                    &mut module,
                    "{IDENT}{IDENT}typedef {ty} {};",
                    self.module_name
                )
                .unwrap();
                writeln!(&mut module, "{IDENT}]]\n").unwrap();
            }
        }
        writeln!(
            &mut module,
            "{IDENT}return {}, '{}'",
            self.type_decl.id(),
            self.module_name
        )
        .unwrap();

        writeln!(&mut module, "end\n").unwrap();

        // Type definition
        writeln!(&mut module, "function Loader.defineType()").unwrap();

        writeln!(&mut module, "{IDENT}local ffi = require('ffi')").unwrap();
        writeln!(&mut module, "{IDENT}local libphx = require('libphx').lib").unwrap();
        writeln!(&mut module, "{IDENT}local {}\n", self.module_name).unwrap();

        // C Definitions
        writeln!(&mut module, "{IDENT}do -- C Definitions").unwrap();
        writeln!(&mut module, "{IDENT}{IDENT}ffi.cdef [[").unwrap();

        self.c_definitions
            .iter()
            .for_each(|def| writeln!(&mut module, "{def}").unwrap());

        writeln!(&mut module, "{IDENT}{IDENT}]]").unwrap();
        writeln!(&mut module, "{IDENT}end\n").unwrap();

        // Global Symbol Table
        writeln!(&mut module, "{IDENT}do -- Global Symbol Table").unwrap();

        if !self.global_symbol_table.is_empty() {
            writeln!(&mut module, "{IDENT}{IDENT}{} = {{", self.module_name).unwrap();

            self.global_symbol_table
                .iter()
                .for_each(|def| writeln!(&mut module, "{def}").unwrap());

            writeln!(&mut module, "{IDENT}{IDENT}}}\n").unwrap();
        } else {
            writeln!(&mut module, "{IDENT}{IDENT}{} = {{}}\n", self.module_name).unwrap();
        }

        if self.is_mt_clone {
            writeln!(&mut module, "{IDENT}{IDENT}local mt = {{").unwrap();
            writeln!(
                &mut module,
                "{IDENT}{IDENT}{IDENT}__call = function(t, ...) return {}_t(...) end,",
                self.module_name
            )
            .unwrap();
            writeln!(&mut module, "{IDENT}{IDENT}}}\n").unwrap();
        }

        writeln!(
            &mut module,
            "{IDENT}{IDENT}if onDef_{0} then onDef_{0}({0}, mt) end",
            self.module_name
        )
        .unwrap();
        writeln!(
            &mut module,
            "{IDENT}{IDENT}{0} = setmetatable({0}, mt)",
            self.module_name
        )
        .unwrap();
        writeln!(&mut module, "{IDENT}end\n").unwrap();

        // Metatype for class instances
        if self.to_string_method.is_some() || !self.metatype.is_empty() {
            writeln!(&mut module, "{IDENT}do -- Metatype for class instances").unwrap();
            writeln!(
                &mut module,
                "{IDENT}{IDENT}local t  = ffi.typeof('{}')",
                self.module_name
            )
            .unwrap();
            writeln!(&mut module, "{IDENT}{IDENT}local mt = {{").unwrap();

            if let Some(method) = &self.to_string_method {
                writeln!(
                    &mut module,
                    "{IDENT}{IDENT}{IDENT}__tostring = function(self) return ffi.string(libphx.{}_{method}(self)) end,",
                    self.module_name,
                )
                .unwrap();
            }

            writeln!(&mut module, "{IDENT}{IDENT}{IDENT}__index = {{").unwrap();

            self.metatype
                .iter()
                .for_each(|mt| writeln!(&mut module, "{mt}").unwrap());

            writeln!(&mut module, "{IDENT}{IDENT}{IDENT}}},").unwrap();
            writeln!(&mut module, "{IDENT}{IDENT}}}\n").unwrap();

            writeln!(
                &mut module,
                "{IDENT}{IDENT}if onDef_{0}_t then onDef_{0}_t(t, mt) end",
                self.module_name
            )
            .unwrap();
            writeln!(
                &mut module,
                "{IDENT}{IDENT}{}_t = ffi.metatype(t, mt)",
                self.module_name
            )
            .unwrap();
            writeln!(&mut module, "{IDENT}end\n").unwrap();
        }

        writeln!(&mut module, "{IDENT}return {}", self.module_name).unwrap();

        writeln!(&mut module, "end\n").unwrap();
        writeln!(&mut module, "return Loader").unwrap();

        if cfg!(windows) {
            module = module.replace("\n", "\r\n");
        }

        module_file.write_all(module.as_bytes()).unwrap();

        if !self.class_definitions.is_empty() {
            let ffi_meta_dir = from_env_or_default(LUAJIT_FFI_META_DIR_ENV, LUAJIT_FFI_META_DIR);

            let ffi_meta_dir_path = cargo_manifest_dir.join(&ffi_meta_dir);
            assert!(
                ffi_meta_dir_path.exists(),
                "Meta directory '{}' doesn't exist",
                ffi_meta_dir_path.display()
            );

            let ffi_meta_def_path = ffi_meta_dir_path.join(format!("{}.lua", self.module_name));
            let mut meta_def_file = File::create(&ffi_meta_def_path).expect(&format!(
                "Cannot create file: {ffi_meta_def_path:?}\nCurrent folder: {:?}",
                std::env::current_dir()
            ));

            let mut meta_def = String::new();

            // Class declaration
            self.class_definitions
                .iter()
                .for_each(|def| writeln!(&mut meta_def, "{def}").unwrap());

            meta_def_file.write_all(meta_def.as_bytes()).unwrap();
        }
    }
}

fn from_env_or_default(env_var: &str, def_value: &str) -> String {
    match std::env::var(env_var) {
        Ok(var) => {
            if !var.is_empty() {
                var
            } else {
                def_value.into()
            }
        }
        Err(VarError::NotPresent) => def_value.into(),
        Err(err) => {
            println!("Cannot read '{env_var}' environment variable. Use default value: {def_value}. Error: {err}");

            def_value.into()
        }
    }
}
